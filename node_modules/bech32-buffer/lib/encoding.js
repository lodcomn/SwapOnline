"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.expandPrefix = expandPrefix;
exports.verifyChecksum = verifyChecksum;
exports.createChecksum = createChecksum;
exports.encode = encode;
exports.decode = decode;
exports.decodeWithPrefix = decodeWithPrefix;
exports.CHECKSUM_LENGTH = void 0;

var _bitConverter = require("./bit-converter");

// Alphabet for Bech32
var CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
var CHECKSUM_LENGTH = 6;
exports.CHECKSUM_LENGTH = CHECKSUM_LENGTH;

// Reverse lookup for characters
var CHAR_LOOKUP = function () {
  var lookup = typeof Map !== 'undefined' ? new Map() : {
    map: {},
    get: function get(i) {
      return this.map[i];
    },
    set: function set(i, v) {
      this.map[i] = v;
      return this;
    }
  };

  for (var i = 0; i < CHARSET.length; i += 1) {
    lookup.set(CHARSET[i], i);
  }

  return lookup;
}(); // Poly generators


var GEN = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];

function polymod(values) {
  return values.reduce(function (checksum, value) {
    var bits = checksum >> 25;
    var newChecksum = (checksum & 0x1ffffff) << 5 ^ value;
    return GEN.reduce(function (chk, gen, i) {
      return (bits >> i & 1) === 0 ? chk : chk ^ gen;
    }, newChecksum);
  },
  /* initial checksum */
  1);
}
/**
 * Expands a prefix onto the specified output buffer.
 */


function expandPrefix(prefix, outBuffer) {
  for (var i = 0; i < prefix.length; i += 1) {
    var code = prefix.charCodeAt(i);
    outBuffer[i] = code >> 5;
    outBuffer[i + prefix.length + 1] = code & 31;
  }

  outBuffer[prefix.length] = 0;
}
/**
 * Verifies the checksum for a particular buffer.
 */


function verifyChecksum(buffer) {
  return polymod(buffer) === 1;
}
/**
 * Creates a checksum for a buffer and writes it to the last 6 5-bit groups
 * of the buffer.
 */


function createChecksum(buffer) {
  var mod = polymod(buffer) ^ 1;

  for (var i = 0; i < CHECKSUM_LENGTH; i += 1) {
    var shift = 5 * (5 - i);
    buffer[buffer.length - CHECKSUM_LENGTH + i] = mod >> shift & 31;
  }
}
/**
 * Encodes an array of 5-bit groups into a string.
 *
 * @param {Uint8Array} buffer
 * @returns {string}
 *
 * @api private
 */


function encode(buffer) {
  return Array.prototype.reduce.call(buffer, function (acc, bits) {
    return acc + CHARSET[bits];
  }, '');
}
/**
 * Decodes a string into an array of 5-bit groups.
 *
 * @param {string} message
 * @param {Uint8Array} [dst]
 *   Optional array to write the output to. If not specified, the array is created.
 * @returns {Uint8Array}
 *   Array with the result of decoding
 *
 * @throws {Error}
 *   if there are characters in `message` not present in the encoding alphabet
 *
 * @api private
 */


function decode(message, dst) {
  var realDst = dst || (0, _bitConverter.createBitArray)(message.length);

  for (var i = 0; i < message.length; i += 1) {
    var idx = CHAR_LOOKUP.get(message[i]);

    if (idx === undefined) {
      throw new Error("Invalid char in message: ".concat(message[i]));
    }

    realDst[i] = idx;
  }

  return realDst;
}
/**
 * Decodes a string and a human-readable prefix into an array of 5-bit groups.
 * The prefix is expanded as specified by Bech32.
 *
 * @param {string} prefix
 * @param {string} message
 * @returns {Uint8Array}
 *   Array with the result of decoding
 *
 * @api private
 */


function decodeWithPrefix(prefix, message) {
  var len = message.length + 2 * prefix.length + 1;
  var dst = (0, _bitConverter.createBitArray)(len);
  expandPrefix(prefix, dst.subarray(0, 2 * prefix.length + 1));
  decode(message, dst.subarray(2 * prefix.length + 1));
  return dst;
}